<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Transparent Ham Studios">

    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>GAMEPAD</title>
    <link rel="stylesheet" type="text/css" href="index.css">
  </head>
  <body>
    <h1>Gamepad API Test</h1>
    <canvas style="border:1px solid black;" id="canvas-ctl" width="320" height="240"></canvas>
  
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/javascript" src="bower_components/jquery/dist/jquery.min.js"></script>
    <script>
      $(document).ready(function(){
        
      });
      
      var rafId = 0; // will be non-zero if callback is active
      var haveEvents = 'ongamepadconnected' in window;
      var controllers = {};
      var canvas = document.getElementById('canvas-ctl');
      var ctx = canvas.getContext('2d');

      function connecthandler(e) {
        addgamepad(e.gamepad);
        rafId = requestAnimationFrame(updateStatus);
      }

      function addgamepad(gamepad) {
        controllers[gamepad.index] = gamepad;

        // for (var i = 0; i < gamepad.buttons.length; i++) {
        //   
        // }
        // 
        // for (var i = 0; i < gamepad.axes.length; i++) {
        //   
        // }
      }

      function disconnecthandler(e) {
        removegamepad(e.gamepad);
        
        // stop our animation loop if the last controller was disconnected
        if(Object.keys(controllers).length === 0){
          cancelAnimationFrame(rafId);
          rafId = 0;
        }
      }

      function removegamepad(gamepad) {
        delete controllers[gamepad.index];
      }

      function updateStatus() {
        // redraw the background
        ctx.clearRect(0,0, canvas.width, canvas.height);
        
        // ctx.fillStyle = 'blue';
        // ctx.fillRect(0,0, canvas.width, canvas.height);
      
        var i = 0;
        var j;
        var normX, normY;
        var length;
        
        var headX, headY;
        var rootX, rootY;

        for (j in controllers) {
          var controller = controllers[j];

          // for (i = 0; i < controller.buttons.length; i++) {
          //   var val = controller.buttons[i];
          //   var pressed = val == 1.0;
          //   if (typeof(val) == "object") {
          //     pressed = val.pressed;
          //     val = val.value;
          //   }
          // 
          //   var pct = Math.round(val * 100) + "%"; // for analog triggers
          //   
          //   // ---
          // }

          // for (i = 0; i < controller.axes.length; i++) {
          //   // controller.axes[i] + 1 -> moves range to [0, 2]
          // }
          
          rootX = canvas.width/2;
          rootY = canvas.height/2;
          
          // Show the origin if the detected direction components are smaller than a noise threshold
          if(Math.abs(controller.axes[0]) < 0.03125 && Math.abs(controller.axes[1]) < 0.03125){
            ctx.fillRect(rootX - 4, rootY - 4, 8,8);
          }
          // Draw a direction ray from the center of the canvas
          else {
            length = Math.sqrt(controller.axes[0]*controller.axes[0] + controller.axes[1]*controller.axes[1]);
            
            normX = controller.axes[0] / length;
            normY = controller.axes[1] / length;
            
            headX = rootX + (normX * canvas.height/2); // scaling by smallest canvas dimension
            headY = rootY + (normY * canvas.height/2);
            
            ctx.beginPath();
            ctx.moveTo(rootX, rootY);
            ctx.lineTo(headX, headY);
            ctx.stroke();
          }
        }

        rafId = requestAnimationFrame(updateStatus);
      }
      
      function scanhandler(){
        scangamepads();
        
        // Possibilities:
        // 0 -> 0: request, then imm. cancel frame
        // 0 -> 1+: request frame
        // 1+ -> 0: cancel frame
        // 1+ -> 1+: do nothing
        
        if(rafId === 0)
          rafId = requestAnimationFrame(updateStatus);
        
        // stop our animation loop if the last controller was disconnected
        if(Object.keys(controllers).length === 0){
          cancelAnimationFrame(rafId);
          rafId = 0;
        }
      }

      function scangamepads() {
        // Completely wipe the controllers object, to capture removed gamepads as well.
        controllers = {};
      
        var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
        
        if(!gamepads) // will be null if no controllers connected, or empty array if not supported
          return;
        
        for (var i = 0; i < gamepads.length; i++) {
          if (gamepads[i]) // MDN claims that the first elem is always null
            addgamepad(gamepads[i]);
        }
      }


      window.addEventListener("gamepadconnected", connecthandler);
      window.addEventListener("gamepaddisconnected", disconnecthandler);

      if (!haveEvents) {
        setInterval(scanhandler, 500);
      }
    </script>
  </body>
</html>